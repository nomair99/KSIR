<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="/styles/game.css">
    <title><%= room.name %></title>
    <link rel="stylesheet" href="/styles/game.css" type="text/css">
    

</head>
<body>
    <div class="header">
        <img src="/styles/ksir.png" alt="ksir" width=220px height=100%>
        <input type="checkbox" id="chk">
        <label for="chk" class="show-menu-btn">
          <i class="fas fa-ellipsis-h"></i>
        </label>
    
        <ul class="menu">
          <a href="/">Home</a>
          <a href="/about">About</a>
          <a href="/privacy">Privacy</a>
          <!-- <a href="#">Contact</a> -->
          <label for="chk" class="hide-menu-btn">
            <i class="fas fa-times"></i>
          </label>
        </ul>
    </div>
    <div id="map"></div>
    <div id="game-panel">
        <div id="phase-indicator"></div>
        <div class="end-phase">End Phase</div>
    </div>

    <div id="die_pop_content">
    <div class="top">
        <a href="javascript:void(0)" id="cancel">&#935;</a>
    </div>
     <div class="dice">
      <ol class="die-list even-roll" data-roll="1" id="die-1">
        <li class="die-item" data-side="1">
          <span class="dot"></span>
        </li>
        <li class="die-item" data-side="2">
          <span class="dot"></span>
          <span class="dot"></span>
        </li>
        <li class="die-item" data-side="3">
          <span class="dot"></span>
          <span class="dot"></span>
          <span class="dot"></span>
        </li>
        <li class="die-item" data-side="4">
          <span class="dot"></span>
          <span class="dot"></span>
          <span class="dot"></span>
          <span class="dot"></span>
        </li>
        <li class="die-item" data-side="5">
          <span class="dot"></span>
          <span class="dot"></span>
          <span class="dot"></span>
          <span class="dot"></span>
          <span class="dot"></span>
        </li>
        <li class="die-item" data-side="6">
          <span class="dot"></span>
          <span class="dot"></span>
          <span class="dot"></span>
          <span class="dot"></span>
          <span class="dot"></span>
          <span class="dot"></span>
        </li>
      </ol>
      <ol class="die-list even-roll" data-roll="1" id="die-1">
        <li class="die-item" data-side="1">
          <span class="dot"></span>
        </li>
        <li class="die-item" data-side="2">
          <span class="dot"></span>
          <span class="dot"></span>
        </li>
        <li class="die-item" data-side="3">
          <span class="dot"></span>
          <span class="dot"></span>
          <span class="dot"></span>
        </li>
        <li class="die-item" data-side="4">
          <span class="dot"></span>
          <span class="dot"></span>
          <span class="dot"></span>
          <span class="dot"></span>
        </li>
        <li class="die-item" data-side="5">
          <span class="dot"></span>
          <span class="dot"></span>
          <span class="dot"></span>
          <span class="dot"></span>
          <span class="dot"></span>
        </li>
        <li class="die-item" data-side="6">
          <span class="dot"></span>
          <span class="dot"></span>
          <span class="dot"></span>
          <span class="dot"></span>
          <span class="dot"></span>
          <span class="dot"></span>
        </li>
      </ol>
      <ol class="die-list odd-roll" data-roll="1" id="die-2">
        <li class="die-item" data-side="1">
          <span class="dot"></span>
        </li>
        <li class="die-item" data-side="2">
          <span class="dot"></span>
          <span class="dot"></span>
        </li>
        <li class="die-item" data-side="3">
          <span class="dot"></span>
          <span class="dot"></span>
          <span class="dot"></span>
        </li>
        <li class="die-item" data-side="4">
          <span class="dot"></span>
          <span class="dot"></span>
          <span class="dot"></span>
          <span class="dot"></span>
        </li>
        <li class="die-item" data-side="5">
          <span class="dot"></span>
          <span class="dot"></span>
          <span class="dot"></span>
          <span class="dot"></span>
          <span class="dot"></span>
        </li>
        <li class="die-item" data-side="6">
          <span class="dot"></span>
          <span class="dot"></span>
          <span class="dot"></span>
          <span class="dot"></span>
          <span class="dot"></span>
          <span class="dot"></span>
        </li>
      </ol>
      <ol class="die-list odd-roll" data-roll="1" id="die-2">
        <li class="die-item" data-side="1">
          <span class="dot"></span>
        </li>
        <li class="die-item" data-side="2">
          <span class="dot"></span>
          <span class="dot"></span>
        </li>
        <li class="die-item" data-side="3">
          <span class="dot"></span>
          <span class="dot"></span>
          <span class="dot"></span>
        </li>
        <li class="die-item" data-side="4">
          <span class="dot"></span>
          <span class="dot"></span>
          <span class="dot"></span>
          <span class="dot"></span>
        </li>
        <li class="die-item" data-side="5">
          <span class="dot"></span>
          <span class="dot"></span>
          <span class="dot"></span>
          <span class="dot"></span>
          <span class="dot"></span>
        </li>
        <li class="die-item" data-side="6">
          <span class="dot"></span>
          <span class="dot"></span>
          <span class="dot"></span>
          <span class="dot"></span>
          <span class="dot"></span>
          <span class="dot"></span>
        </li>
      </ol>
    </div>
    <button type="button" id="roll-button">Roll Dice</button>
</div>
<div  id="popupposition">
    <div class = "popupwrapper">
        <div class = "popupcontent">
            <h2>How Many Troops?</h2>
            <div class = "popupbuttons"></div>
            <button class="cancel">Cancel</button>
        </div>
    </div>
</div>
    <script src="./die_app.js"></script>

    <script>
        function cancel() {
           let d = document.getElementById("die_pop_content");
           d.style.display="none";
        }
        function rollDice() {
          const dice = [...document.querySelectorAll(".die-list")];
          dice.forEach(die => {
            toggleClasses(die);
            die.dataset.roll = getRandomNumber(1, 6);
          });
        }
        function toggleClasses(die) {
          die.classList.toggle("odd-roll");
          die.classList.toggle("even-roll");
        }

        function getRandomNumber(min, max) {
          min = Math.ceil(min);
          max = Math.floor(max);
          return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        document.getElementById("roll-button").addEventListener("click", rollDice);
        document.getElementById("cancel").addEventListener("click", cancel);
    </script>

    <script src="https://cdn.jsdelivr.net/npm/socket.io-client@2/dist/socket.io.js"></script>
    <script src="http://cdnjs.cloudflare.com/ajax/libs/raphael/2.1.0/raphael-min.js"></script>
    <script>
        var graph;
        var regions = {};
        var selectedRegion = null;
        var selectedRegionIndex = null;
        var neighborRegions = [];
        var troopMarkers = {};
        var regionCircles = {};
        var currentPlayerIndex = 0;
        var reinforcementsRemaining = 0;
        var playerList, currentPlayer, thisPlayer;
        var phase = 'reinforcement';
        var movedThisTurn = false;
        var attackMoveRegionIndexFrom = null;
        var attackMoveRegionIndexTo = null;

        var style = {
            fill: "#ddd",
            stroke: "#f0d384",
            "stroke-width": 2,
            "stroke-linejoin": "round",
            cursor: "pointer"
        };
        var hoverStyle = {
            fill: "#ffabab"
        };
        var neighborHoverStyle = {
            fill: "#824b4b"
        };
        var selectedStyle = {
            fill: "#9c1616"
        };

        var regionCircleStyle = {
            fill: "#353633"
        };
        
        var regionCircleHighlightedStyle = {
            fill: "#FE0032"
        };

        var playerStyles = [];
        playerStyles.push({
           fill: "#bf4b4b"
        });
        playerStyles.push({
            fill: "#117321"
        });
        playerStyles.push({
            fill: "#1f4991"
        });
        playerStyles.push({
            fill: "#929431"
        });

        window.addEventListener('load', function() {
            let container = document.getElementById('map');
            map = new Raphael(container, 620, 600);

            socket = io('/game');

            socket.on('player name', function(data) {
                thisPlayer = data;
            });

            socket.on('player list', function(data) {
                console.log('got player list');
                playerList = data.playerList;
                currentPlayer = playerList[0].player;
                console.log(playerList);
            });

            socket.on('map', function(g) {

                graph = g;

                let playerIndex;
                for(let i = 0; i < graph.nodes.length; i++) {
                    regions[graph.nodes[i].obj.name] = map.path(graph.nodes[i].obj.path);
                    restoreStyle(graph.nodes[i]);
                    let bBox = regions[graph.nodes[i].obj.name].getBBox();

                    // draw circle with number of troops
                    let centerX = bBox.x + bBox.width / 2;
                    let centerY = bBox.y + bBox.height / 2;
                    regionCircles[graph.nodes[i].obj.name] = map.circle(centerX, centerY, 10).attr(regionCircleStyle);
                    troopMarkers[graph.nodes[i].obj.name] = map.text(centerX, centerY, graph.nodes[i].obj.troops).attr({fill: "white"});

                    regions[graph.nodes[i].obj.name][0].addEventListener('mouseover', function() {

                        // ? what if two regions have the same name
                        if(graph.nodes[i].obj.name !== selectedRegion) {
                            regions[graph.nodes[i].obj.name].animate(hoverStyle, 0);
                        }
                    }, true);
                    regions[graph.nodes[i].obj.name][0].addEventListener('click', function(e) {
                        e.stopPropagation();
                        if(currentPlayer !== thisPlayer) {
                            // don't allow selection if it's not this player's turn
                            return;
                        }

                        // clear all styles
                        restoreAllStyles();
                        
                        // TODO show a popup to select the number of troops to move
                        if(phase === 'reinforcement' && graph.nodes[i].obj.owner === thisPlayer) {
                            if(reinforcementsRemaining > 0) {
                                regions[graph.nodes[i].obj.name].animate(selectedStyle, 0);
                                selectroops(i, null);
                            }

                            //Craps animation
                            // let d = document.getElementById("die_pop_content");
                            // d.style.display="block";
                        } else if(phase === 'attack') {

                            if(selectedRegion && neighborRegions.indexOf(graph.nodes[i].obj.name) !== -1 && graph.nodes[i].obj.owner !== thisPlayer) {
                                // a region was selected and the user then clicked on a neighboring region that belonged to an opponent
    
                                if(graph.nodes[selectedRegionIndex].obj.troops > 1) {
                                    selectroops(selectedRegionIndex, i);
                                } else {
                                    showNotification(`${selectedRegion} has only one troop!`);
                                }

                                selectedRegion = null;
                                selectedRegionIndex = null;
                                neighborRegions = [];
                            } else {
                                if(graph.nodes[i].obj.name !== selectedRegion && graph.nodes[i].obj.owner === thisPlayer) {
                                    for(let j = 0; j < graph.nodes.length; j++) {
                                        if(graph.adjacencyMatrix[i][j] && graph.nodes[j].obj.owner !== thisPlayer) {
                                            neighborRegions.push(graph.nodes[j].obj.name);
                                            regions[graph.nodes[j].obj.name].attr(neighborHoverStyle);
                                        }
                                    }
                                    
                                    regions[graph.nodes[i].obj.name].attr(selectedStyle);
                                    selectedRegion = graph.nodes[i].obj.name;
                                    selectedRegionIndex = i;
                                } else {
                                    selectedRegion = null;
                                    selectedRegionIndex = null;
                                    neighborRegions = [];
                                }
                            }
                        } else if(phase === 'move' && !movedThisTurn) {
                            if(selectedRegion && neighborRegions.indexOf(graph.nodes[i].obj.name) !== -1) {
                                selectroops(selectedRegionIndex, i);
                            } else {
                                restoreAllStyles();
                                selectedRegionIndex = i;
                                selectedRegion = graph.nodes[i].obj.name;
                                regions[selectedRegion].attr(selectedStyle);
                                for(let j = 0; j < graph.nodes.length; j++) {

                                    // ! placeholder. only allows moving to adjacents. implement routeExists and replace
                                    if(i !== j && graph.nodes[j].obj.owner === thisPlayer && graph.adjacencyMatrix[i][j]) {
                                            neighborRegions.push(graph.nodes[j].obj.name);
                                            regions[graph.nodes[j].obj.name].attr(neighborHoverStyle);
                                    }
                                }
                            }
                        }
                    }, true);

                    regions[graph.nodes[i].obj.name][0].addEventListener('mouseout', function() {

                        if(graph.nodes[i].obj.name === selectedRegion) {
                            regions[graph.nodes[i].obj.name].animate(selectedStyle, 0);
                        } else if(neighborRegions.indexOf(graph.nodes[i].obj.name) !== -1) {
                            regions[graph.nodes[i].obj.name].animate(neighborHoverStyle, 0);
                        } else {
                            restoreStyle(graph.nodes[i]);
                        }
                    }, true);
                }
            });

            socket.on('attack', function(data) {
                console.log('Got attack event');

                let notificationText = `${currentPlayer} attacked ${data.to} from ${data.from} with ${data.num} troops!`;
                let indexFrom, indexTo;
                for(let i = 0; i < graph.nodes.length; i++) {
                    if(graph.nodes[i].obj.name === data.from) {
                        indexFrom = i;
                        console.log('Updating marker');
                        graph.nodes[i].obj.troops -= data.attackingDeaths;
                        troopMarkers[data.from].attr({text: graph.nodes[i].obj.troops})
                    }
                    if(graph.nodes[i].obj.name === data.to) {
                        indexTo = i;
                        console.log('Updating marker');
                        graph.nodes[i].obj.troops -= data.defendingDeaths;
                        troopMarkers[data.to].attr({text: graph.nodes[i].obj.troops});
                        
                    }
                }

                regionCircles[data.from].attr(regionCircleHighlightedStyle);
                regionCircles[data.to].attr(regionCircleHighlightedStyle);
                setInterval(function() {
                    regionCircles[data.from].attr(regionCircleStyle);
                    regionCircles[data.to].attr(regionCircleStyle);
                }, 1500);

                if(data.defeated) {
                    let defeatedPlayer;
                    for(let j = 0; j < playerList.length; j++) {
                        if(playerList[j].player === graph.nodes[indexTo].obj.owner) {
                            playerList[j].alive = false;
                            defeatedPlayer = playerList[j].player;
                            break;
                        }
                    }

                    notificationText += `${defeatedPlayer} was defeated!`;
                    // ? show animation
                }
                
                if(data.conquered) {
                    graph.nodes[indexTo].obj.owner = graph.nodes[indexFrom].obj.owner;
                    notificationText += `${data.to} was conquered!`;
                    // TODO switch to attack move phase

                    if(graph.nodes[indexFrom].obj.troops > 1) {
                        // allow player to move additional troops

                        phase = "attack move";
                        attackMoveRegionIndexFrom = indexFrom;
                        attackMoveRegionIndexTo = indexTo;
                        showNotification(`${currentPlayer} is moving troops into ${data.to}!`);
                        
                        if(thisPlayer === currentPlayer) {
                            selectroops(indexFrom, indexTo);
                        }
                    }
                }

                restoreAllStyles();
                showNotification(notificationText);
            });

            socket.on('attack move', function(data) {
                console.log('got attack move event');
                graph.nodes[attackMoveRegionIndexFrom].obj.troops -= data.num;
                graph.nodes[attackMoveRegionIndexTo].obj.troops += data.num;

                troopMarkers[graph.nodes[attackMoveRegionIndexFrom].obj.name].attr({text: graph.nodes[attackMoveRegionIndexFrom].obj.troops});
                troopMarkers[graph.nodes[attackMoveRegionIndexTo].obj.name].attr({text: graph.nodes[attackMoveRegionIndexTo].obj.troops});
                
                let troopForm = data.num === 1 ? 'troop' : 'troops';
                showNotification(`${currentPlayer} moved ${data.num} additional ${troopForm} into ${graph.nodes[attackMoveRegionIndexTo].obj.name}!`);
                phase = 'attack';
            });

            socket.on('move', function(data) {
                let indexFrom, indexTo;

                for(let j = 0; j < graph.nodes.length; j++) {
                    if(graph.nodes[j].obj.name === data.from) {
                        graph.nodes[j].obj.troops -= data.num;
                        troopMarkers[graph.nodes[j].obj.name].attr({text: graph.nodes[j].obj.troops});
                    } else if(graph.nodes[j].obj.name === data.to) {
                        graph.nodes[j].obj.troops += data.num;
                        troopMarkers[graph.nodes[j].obj.name].attr({text: graph.nodes[j].obj.troops});
                    }
                }

                let troopsForm = data.num === 1 ? 'troop' : 'troops';
                showNotification(`${currentPlayer} moved ${data.num} ${troopsForm} from ${data.from} to ${data.to}!`);
            });

            socket.on('reinforce', function(data) {
                console.log('got reinforce event');
                for(let i = 0; i < graph.nodes.length; i++) {
                    if(graph.nodes[i].obj.name === data.region) {
                        graph.nodes[i].obj.troops += data.num;
                        troopMarkers[data.region].attr({text: graph.nodes[i].obj.troops});
                        break;
                    }
                }

                reinforcementsRemaining -= data.num;
                updateReinforcementsRemaining();

                if(thisPlayer === currentPlayer && reinforcementsRemaining <= 0) {
                    document.querySelector('.end-phase').classList.add('can-click');
                }

                showNotification(`${currentPlayer} reinforced ${data.region} with ${data.num} troops!`);

                if(canEndPhase()) {
                    // TODO disable button
                } else {
                }
            });

            socket.on('reinforcements remaining', function(num) {
                reinforcementsRemaining = num;
                updateReinforcementsRemaining(); 
            });
            
            // ? should the 'attack move' phase be included here
            socket.on('end phase', function(data) {
                console.log('got end phase event');

                if(phase === 'reinforcement') {
                    phase = 'attack';
                    if(thisPlayer !== currentPlayer) {
                        document.querySelector('.end-phase').classList.remove('can-click');
                    } else {
                        document.querySelector('.end-phase').classList.add('can-click');
                    }
                    updatePhaseIndicatorText(`${currentPlayer} Attacking`);
                    showNotification(`${currentPlayer} moved onto the attack phase!`);
                } else if(phase === 'attack') {
                    updatePhaseIndicatorText(`${currentPlayer} Moving`);
                    phase = 'move';
                    if(thisPlayer !== currentPlayer) {
                        document.querySelector('.end-phase').classList.remove('can-click');
                    } else {
                        document.querySelector('.end-phase').classList.add('can-click');
                    }
                    movedThisTurn = false;
                    showNotification(`${currentPlayer} moved onto the movement phase!`);
                } else if(phase === 'move') {
                    phase = 'reinforcement';
                    document.querySelector('.end-phase').classList.remove('can-click');
                    switchPlayer();
                    
                    showNotification(`It's ${currentPlayer}'s' turn!`);
                }
            });
        });

        var endPhaseBtn = document.querySelector('.end-phase');

        endPhaseBtn.addEventListener('click', function(e) {
            e.stopPropagation();

            if(canEndPhase()) {
                socket.emit('end phase', null);
            }
        });

        document.addEventListener('click', function(e) {
            selectedRegion = null;
            neighborRegions = [];
            restoreAllStyles();
        });

        function restoreStyle(node) {
            let playerIndex;
            for(let j = 0; j < playerList.length; j++) {
                if(playerList[j].player === node.obj.owner) {
                    playerIndex = j;
                    break;
                }
            }

            regions[node.obj.name].attr(style);
            regions[node.obj.name].attr(playerStyles[playerIndex]);
        }

        function restoreAllStyles() {
            for(let j = 0; j < graph.nodes.length; j++) {
                restoreStyle(graph.nodes[j]);
            }
        }

        function updatePhaseIndicatorText(text) {
            let phaseIndicator = document.querySelector('#phase-indicator');
    
            // remove existing text
            while(phaseIndicator.firstChild) {
                phaseIndicator.removeChild(phaseIndicator.firstChild);
            }
    
            // display new text
            phaseIndicator.appendChild(document.createTextNode(text));
        }

        function updateReinforcementsRemaining() {
            console.log(`updating reinforcements remaining: ${reinforcementsRemaining}`);
            updatePhaseIndicatorText(`${currentPlayer} Reinforcing. Troops Remaining: ${reinforcementsRemaining}`);
        }

        function switchPlayer() {

            do {
                currentPlayerIndex = (currentPlayerIndex + 1) % playerList.length;
                currentPlayer = playerList[currentPlayerIndex].player;
            } while(!playerList[currentPlayerIndex].alive);
        }

        function nextPhase() {
            if(phase === 'reinforcement') {
                phase = 'attack';
            } else if(phase === 'attack') {
                phase = 'move';
            } else if(phase === 'move') {
                phase = 'reinforcement';
                switchPlayer();
            }
        }

        function selectroops(indexFrom, indexTo) {
            // TODO allow changing header text
            let popup = document.querySelector(".popupbuttons");
            let cancel = document.querySelector(".cancel")
            toggle_visibility("popupposition");

            cancel.disabled = false;

            function closePopup() {
                toggle_visibility("popupposition");
                while(popup.firstChild) {
                    popup.removeChild(popup.firstChild);
                }
                restoreAllStyles();
                selectedRegion = null;
                neighborRegions = [];
            };

            if(phase === 'reinforcement') {
                let n = reinforcementsRemaining;
                for(let i = 0; i < n; i++) {
                    let elem = document.createElement('input');
                    elem.type = 'button';
                    elem.value = i + 1;
                    elem.className = "pickerbutton";
                    elem.addEventListener('click', function(e) {
                        console.log('clicked');
                        e.stopPropagation();
                        selectedRegion = graph.nodes[indexFrom].obj.name;
                        socket.emit('reinforce', {
                            region: graph.nodes[indexFrom].obj.name,
                            num: i+1
                        });

                        closePopup();
                    });
                    
                    popup.appendChild(elem);
                }
            } else if(phase === 'attack') {
                let n = Math.min(3, graph.nodes[indexFrom].obj.troops - 1);
                for(let i = 0; i < n; i++) {
                    let elem = document.createElement('input');
                    elem.type = 'button';
                    elem.value = i + 1;
                    elem.className = "pickerbutton";
                    elem.addEventListener('click', function(e) {
                        e.stopPropagation();
                        
                        let regionFrom = graph.nodes[indexFrom].obj.name;
                        let regionTo = graph.nodes[indexTo].obj.name;

                        socket.emit('attack', {
                            from: regionFrom,
                            to: regionTo,
                            num: i+1
                        });

                        closePopup();
                    });
                    
                    popup.appendChild(elem);
                }
            } else if(phase === 'attack move') {
                let n = graph.nodes[indexFrom].obj.troops - 1;
                for(let i = 0; i <= n; i++) {
                    let elem = document.createElement('input');
                    elem.type = 'button';
                    elem.value = i;
                    elem.className = "pickerbutton";
                    elem.addEventListener('click', function(e) {
                        e.stopPropagation();
                        
                        socket.emit('attack move', {
                            num: i
                        });

                        closePopup();
                    });
                    
                    popup.appendChild(elem);
                }
                
                // can't cancel 'attack move'
                cancel.disabled = true;
            } else if(phase === 'move') {
                let n = graph.nodes[indexFrom].obj.troops - 1;
                for(let i = 0; i <= n; i++) {
                    let elem = document.createElement('input');
                    elem.type = 'button';
                    elem.value = i;
                    elem.className = "pickerbutton";
                    elem.addEventListener('click', function(e) {
                        e.stopPropagation();
                        
                        socket.emit('move', {
                            from: graph.nodes[indexFrom].obj.name,
                            to: graph.nodes[indexTo].obj.name,
                            num: i
                        });
                        movedThisTurn = true;

                        closePopup();
                    });
                    
                    popup.appendChild(elem);
                }

            }

            cancel.onclick = function(e) {
                e.stopPropagation();
                closePopup();
            };
        }

        function showNotification(text) {
            let bodyNode = document.querySelector('body');
            let notificationBox = document.createElement('div');
            notificationBox.classList.add('notification');
            notificationBox.classList.add('popnotification');
            let notificationText = document.createElement('p');
            notificationText.appendChild(document.createTextNode(text));
            notificationBox.appendChild(notificationText);
            bodyNode.appendChild(notificationBox);

            setInterval(function() {
                bodyNode.removeChild(notificationBox);
            }, 4000);
        }

        function canEndPhase() {
            if(thisPlayer === currentPlayer) {
                // only the current player can end phase

                if(phase === 'reinforcement') {
                    return reinforcementsRemaining <= 0;
                } else if(phase === 'attack' || phase === 'move') {
                    return true;
                }
            }

            return false;
        }

        function toggle_visibility(id) {
            let n = document.getElementById(id);
            if(n.style.display === 'block') {
                n.style.display = 'none';
            } else {
                n.style.display = 'block';
            }
        }

        function routeExists() {

        }
    </script>
</body>
</html>
